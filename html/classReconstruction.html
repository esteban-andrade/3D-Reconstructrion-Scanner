<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Reconstruction: Reconstruction Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Reconstruction
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classReconstruction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Reconstruction Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Class <a class="el" href="classReconstruction.html" title="The Class Reconstruction is used process the target pointcloud. It contain many implemeted algorithms...">Reconstruction</a> is used process the target pointcloud. It contain many implemeted algorithms used for filtering, segmentation, clusteting, etc.  
 <a href="classReconstruction.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Reconstruction_8h_source.html">Reconstruction.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a081657a94b56a22f530f6661f356906a"><td class="memItemLeft" align="right" valign="top"><a id="a081657a94b56a22f530f6661f356906a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a081657a94b56a22f530f6661f356906a">Reconstruction</a> ()</td></tr>
<tr class="memdesc:a081657a94b56a22f530f6661f356906a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classReconstruction.html" title="The Class Reconstruction is used process the target pointcloud. It contain many implemeted algorithms...">Reconstruction</a> object. <br /></td></tr>
<tr class="separator:a081657a94b56a22f530f6661f356906a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ac62559b5825dcec2a760946897f40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#ac7ac62559b5825dcec2a760946897f40">Reconstruction</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, std::string)</td></tr>
<tr class="memdesc:ac7ac62559b5825dcec2a760946897f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classReconstruction.html" title="The Class Reconstruction is used process the target pointcloud. It contain many implemeted algorithms...">Reconstruction</a> object.  <a href="#ac7ac62559b5825dcec2a760946897f40">More...</a><br /></td></tr>
<tr class="separator:ac7ac62559b5825dcec2a760946897f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039a0f69fa30bd88ffadf608846a316d"><td class="memItemLeft" align="right" valign="top"><a id="a039a0f69fa30bd88ffadf608846a316d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a039a0f69fa30bd88ffadf608846a316d">~Reconstruction</a> ()</td></tr>
<tr class="memdesc:a039a0f69fa30bd88ffadf608846a316d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classReconstruction.html" title="The Class Reconstruction is used process the target pointcloud. It contain many implemeted algorithms...">Reconstruction</a> object. <br /></td></tr>
<tr class="separator:a039a0f69fa30bd88ffadf608846a316d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be86587dfe645c245474315ae67f5e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a8be86587dfe645c245474315ae67f5e4">setInputCloud</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, std::string, bool)</td></tr>
<tr class="memdesc:a8be86587dfe645c245474315ae67f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Input Cloud object.  <a href="#a8be86587dfe645c245474315ae67f5e4">More...</a><br /></td></tr>
<tr class="separator:a8be86587dfe645c245474315ae67f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d79600ed8684f67c1c56456bd9142b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a16d79600ed8684f67c1c56456bd9142b">normalsDirectionAdjustment</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PolygonMesh::Ptr &amp;)</td></tr>
<tr class="memdesc:a16d79600ed8684f67c1c56456bd9142b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the normals of the point cloud.  <a href="#a16d79600ed8684f67c1c56456bd9142b">More...</a><br /></td></tr>
<tr class="separator:a16d79600ed8684f67c1c56456bd9142b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab58cb52a7507ed64640c5e6645f296e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#aab58cb52a7507ed64640c5e6645f296e">pointCloudOutliersFilter</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;)</td></tr>
<tr class="memdesc:aab58cb52a7507ed64640c5e6645f296e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API takes an reference cloud and outputs a processedpoint cloud with filtered data outliers.  <a href="#aab58cb52a7507ed64640c5e6645f296e">More...</a><br /></td></tr>
<tr class="separator:aab58cb52a7507ed64640c5e6645f296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea61518d67180a5d9d131d29a1b78c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a1ea61518d67180a5d9d131d29a1b78c8">pointCloudPlaneSegmentOperation</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;)</td></tr>
<tr class="memdesc:a1ea61518d67180a5d9d131d29a1b78c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">this API is degined to input a given PointCloud and output a plane segmented point cloud.  <a href="#a1ea61518d67180a5d9d131d29a1b78c8">More...</a><br /></td></tr>
<tr class="separator:a1ea61518d67180a5d9d131d29a1b78c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9249ed4c0932b9fe460fada09ce38e67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a9249ed4c0932b9fe460fada09ce38e67">pointCloudClustering</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;)</td></tr>
<tr class="memdesc:a9249ed4c0932b9fe460fada09ce38e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is designed to Input a specific point cloud and runan Euclidean Cluster Extraction (.  <a href="#a9249ed4c0932b9fe460fada09ce38e67">More...</a><br /></td></tr>
<tr class="separator:a9249ed4c0932b9fe460fada09ce38e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5749b9529d6f026ae9bb1084f63b276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#ad5749b9529d6f026ae9bb1084f63b276">pointCloudNormaliseUpscale</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;)</td></tr>
<tr class="memdesc:ad5749b9529d6f026ae9bb1084f63b276"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API aims to smooth the surface of the PointCloud via MLS (MovingLeastSquares).  <a href="#ad5749b9529d6f026ae9bb1084f63b276">More...</a><br /></td></tr>
<tr class="separator:ad5749b9529d6f026ae9bb1084f63b276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42571b72e2c1ca984c259f3f4d319c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a42571b72e2c1ca984c259f3f4d319c75">poissonReconstruction</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PolygonMesh::Ptr &amp;)</td></tr>
<tr class="memdesc:a42571b72e2c1ca984c259f3f4d319c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">his API will require an input pointcloud and it will generatea reconstructed Polymesh based on the Poisson <a class="el" href="classReconstruction.html" title="The Class Reconstruction is used process the target pointcloud. It contain many implemeted algorithms...">Reconstruction</a> Algorithm  <a href="#a42571b72e2c1ca984c259f3f4d319c75">More...</a><br /></td></tr>
<tr class="separator:a42571b72e2c1ca984c259f3f4d319c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8b20ec9b384b9dad21a3accfea98f2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a8e8b20ec9b384b9dad21a3accfea98f2">pointCloudScaleAdjustment</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, bool, bool)</td></tr>
<tr class="separator:a8e8b20ec9b384b9dad21a3accfea98f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26b3c0a0b3739c330b2c48f874c15c9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#aa26b3c0a0b3739c330b2c48f874c15c9">getScale</a> ()</td></tr>
<tr class="memdesc:aa26b3c0a0b3739c330b2c48f874c15c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Scale object.  <a href="#aa26b3c0a0b3739c330b2c48f874c15c9">More...</a><br /></td></tr>
<tr class="separator:aa26b3c0a0b3739c330b2c48f874c15c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7f0942d1540ace69e53c28d3b82023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a1b7f0942d1540ace69e53c28d3b82023">cloudToPolyMesh</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PolygonMesh::Ptr &amp;)</td></tr>
<tr class="memdesc:a1b7f0942d1540ace69e53c28d3b82023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert point cloud to polymesh.  <a href="#a1b7f0942d1540ace69e53c28d3b82023">More...</a><br /></td></tr>
<tr class="separator:a1b7f0942d1540ace69e53c28d3b82023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2151dd4224cee397adb2b353e20e9b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a6c2151dd4224cee397adb2b353e20e9b">manualScaleAdjuster</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, double)</td></tr>
<tr class="memdesc:a6c2151dd4224cee397adb2b353e20e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual Adjuster method.  <a href="#a6c2151dd4224cee397adb2b353e20e9b">More...</a><br /></td></tr>
<tr class="separator:a6c2151dd4224cee397adb2b353e20e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cab918422a3c74bced403043968992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a46cab918422a3c74bced403043968992">convertPLYtoPCL</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, std::string)</td></tr>
<tr class="memdesc:a46cab918422a3c74bced403043968992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert point cloud to ply file.  <a href="#a46cab918422a3c74bced403043968992">More...</a><br /></td></tr>
<tr class="separator:a46cab918422a3c74bced403043968992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab7e493f5aee46722977acd64658c7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#afab7e493f5aee46722977acd64658c7a">convertPolyMeshtoPLY</a> (pcl::PolygonMesh::Ptr &amp;, std::string)</td></tr>
<tr class="memdesc:afab7e493f5aee46722977acd64658c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert polymesh to ply file.  <a href="#afab7e493f5aee46722977acd64658c7a">More...</a><br /></td></tr>
<tr class="separator:afab7e493f5aee46722977acd64658c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82138f7b299c7047f53181b6abb70c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a82138f7b299c7047f53181b6abb70c81">downsamplePointCloudVoxelGrid</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, float, float, float)</td></tr>
<tr class="memdesc:a82138f7b299c7047f53181b6abb70c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API aims to downsample the input point-cloud through a voxel grid filter.  <a href="#a82138f7b299c7047f53181b6abb70c81">More...</a><br /></td></tr>
<tr class="separator:a82138f7b299c7047f53181b6abb70c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad287c118ab81ecf00c29f55314fc237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#aad287c118ab81ecf00c29f55314fc237">convertPCLtoPLY</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, std::string)</td></tr>
<tr class="memdesc:aad287c118ab81ecf00c29f55314fc237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert point cloud to ply file.  <a href="#aad287c118ab81ecf00c29f55314fc237">More...</a><br /></td></tr>
<tr class="separator:aad287c118ab81ecf00c29f55314fc237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d96a55242b1849637da44e4e32f725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#ac2d96a55242b1849637da44e4e32f725">importPLYtoPolymesh</a> (std::string, pcl::PolygonMesh::Ptr &amp;)</td></tr>
<tr class="memdesc:ac2d96a55242b1849637da44e4e32f725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imports ply file to polymesh.  <a href="#ac2d96a55242b1849637da44e4e32f725">More...</a><br /></td></tr>
<tr class="separator:ac2d96a55242b1849637da44e4e32f725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b56e19c016b8c32ff99e7c5bacb515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#aa2b56e19c016b8c32ff99e7c5bacb515">passThroughFilter</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, std::string, float, float)</td></tr>
<tr class="memdesc:aa2b56e19c016b8c32ff99e7c5bacb515"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API aims to filter a specific point cloud based on the specificaxis limit, which is known as passThroughFilter.  <a href="#aa2b56e19c016b8c32ff99e7c5bacb515">More...</a><br /></td></tr>
<tr class="separator:aa2b56e19c016b8c32ff99e7c5bacb515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cff09bc04f6579b54932df8eb9b6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#ac7cff09bc04f6579b54932df8eb9b6ab">pointCloudOutliersFilterManual</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, int, double)</td></tr>
<tr class="memdesc:ac7cff09bc04f6579b54932df8eb9b6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API takes an reference cloud and outputs a processedpoint cloud with filtered data outliers.  <a href="#ac7cff09bc04f6579b54932df8eb9b6ab">More...</a><br /></td></tr>
<tr class="separator:ac7cff09bc04f6579b54932df8eb9b6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621af3745966b359e10c02a570658c5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a621af3745966b359e10c02a570658c5c">pointCloudPlaneSegmentOperationManual</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, double, double)</td></tr>
<tr class="memdesc:a621af3745966b359e10c02a570658c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is designed to Input a specific point cloud and runan Euclidean Cluster Extraction (.  <a href="#a621af3745966b359e10c02a570658c5c">More...</a><br /></td></tr>
<tr class="separator:a621af3745966b359e10c02a570658c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9482066c467e769715d5ffde762225"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a0c9482066c467e769715d5ffde762225">pointCloudCentroidAlignmentAdjusment</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, double, double, double)</td></tr>
<tr class="memdesc:a0c9482066c467e769715d5ffde762225"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API aims to align two given pointcloud to its corresponding centroi.  <a href="#a0c9482066c467e769715d5ffde762225">More...</a><br /></td></tr>
<tr class="separator:a0c9482066c467e769715d5ffde762225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc413f7611f3984cbfcff77b9c23df6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#adbc413f7611f3984cbfcff77b9c23df6">normalsReAdjustement</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;)</td></tr>
<tr class="memdesc:adbc413f7611f3984cbfcff77b9c23df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes the normals.  <a href="#adbc413f7611f3984cbfcff77b9c23df6">More...</a><br /></td></tr>
<tr class="separator:adbc413f7611f3984cbfcff77b9c23df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b679093ca295de818b4bdf84ec79af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#ab8b679093ca295de818b4bdf84ec79af">normalsTesting</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;)</td></tr>
<tr class="memdesc:ab8b679093ca295de818b4bdf84ec79af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjuste normals.  <a href="#ab8b679093ca295de818b4bdf84ec79af">More...</a><br /></td></tr>
<tr class="separator:ab8b679093ca295de818b4bdf84ec79af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cf80cebcf9600860881f57a8986823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a74cf80cebcf9600860881f57a8986823">transformPointCloud</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;)</td></tr>
<tr class="memdesc:a74cf80cebcf9600860881f57a8986823"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will transform one point cloud based on the input reference point cloud and use that transform pose.  <a href="#a74cf80cebcf9600860881f57a8986823">More...</a><br /></td></tr>
<tr class="separator:a74cf80cebcf9600860881f57a8986823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c384d0419386505e5fe58a55b556c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReconstruction.html#a73c384d0419386505e5fe58a55b556c9">transformVerification</a> (pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;, pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;)</td></tr>
<tr class="memdesc:a73c384d0419386505e5fe58a55b556c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">It will verify the transform and check based on a given thershold.  <a href="#a73c384d0419386505e5fe58a55b556c9">More...</a><br /></td></tr>
<tr class="separator:a73c384d0419386505e5fe58a55b556c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Class <a class="el" href="classReconstruction.html" title="The Class Reconstruction is used process the target pointcloud. It contain many implemeted algorithms...">Reconstruction</a> is used process the target pointcloud. It contain many implemeted algorithms used for filtering, segmentation, clusteting, etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac7ac62559b5825dcec2a760946897f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ac62559b5825dcec2a760946897f40">&#9670;&nbsp;</a></span>Reconstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Reconstruction::Reconstruction </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classReconstruction.html" title="The Class Reconstruction is used process the target pointcloud. It contain many implemeted algorithms...">Reconstruction</a> object. </p>
<dl class="section note"><dt>Note</dt><dd>Only for ply file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>pointcloud point cloud used to hold the input mesh </td></tr>
    <tr><td class="paramname">path_file</td><td>: string used to hold the path of the input file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b7f0942d1540ace69e53c28d3b82023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7f0942d1540ace69e53c28d3b82023">&#9670;&nbsp;</a></span>cloudToPolyMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::cloudToPolyMesh </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>ref_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PolygonMesh::Ptr &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert point cloud to polymesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_cloud</td><td>Reference Point cloud </td></tr>
    <tr><td class="paramname">mesh</td><td>outout mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad287c118ab81ecf00c29f55314fc237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad287c118ab81ecf00c29f55314fc237">&#9670;&nbsp;</a></span>convertPCLtoPLY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::convertPCLtoPLY </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert point cloud to ply file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input Point cloud </td></tr>
    <tr><td class="paramname">target_path</td><td>File and path of file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46cab918422a3c74bced403043968992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cab918422a3c74bced403043968992">&#9670;&nbsp;</a></span>convertPLYtoPCL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::convertPLYtoPCL </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_clopud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ply_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert point cloud to ply file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target_clopud</td><td>output Point cloud </td></tr>
    <tr><td class="paramname">ply_file</td><td>File and path of file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afab7e493f5aee46722977acd64658c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab7e493f5aee46722977acd64658c7a">&#9670;&nbsp;</a></span>convertPolyMeshtoPLY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::convertPolyMeshtoPLY </td>
          <td>(</td>
          <td class="paramtype">pcl::PolygonMesh::Ptr &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>target_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert polymesh to ply file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>input Point cloud </td></tr>
    <tr><td class="paramname">target_path</td><td>File and path of file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82138f7b299c7047f53181b6abb70c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82138f7b299c7047f53181b6abb70c81">&#9670;&nbsp;</a></span>downsamplePointCloudVoxelGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::downsamplePointCloudVoxelGrid </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>input_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API aims to downsample the input point-cloud through a voxel grid filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_cloud</td><td>input Point cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>Output point cloud </td></tr>
    <tr><td class="paramname">lx</td><td>x dimension of voxel </td></tr>
    <tr><td class="paramname">ly</td><td>y dimension of voxel </td></tr>
    <tr><td class="paramname">lz</td><td>x dimension of voxel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa26b3c0a0b3739c330b2c48f874c15c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26b3c0a0b3739c330b2c48f874c15c9">&#9670;&nbsp;</a></span>getScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Reconstruction::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Scale object. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;double&gt; </dd></dl>

</div>
</div>
<a id="ac2d96a55242b1849637da44e4e32f725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d96a55242b1849637da44e4e32f725">&#9670;&nbsp;</a></span>importPLYtoPolymesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::importPLYtoPolymesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PolygonMesh::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imports ply file to polymesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>path of ply file </td></tr>
    <tr><td class="paramname">target</td><td>target polymesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c2151dd4224cee397adb2b353e20e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2151dd4224cee397adb2b353e20e9b">&#9670;&nbsp;</a></span>manualScaleAdjuster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &gt; Reconstruction::manualScaleAdjuster </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>input_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manual Adjuster method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_cloud</td><td>Input Point cloud </td></tr>
    <tr><td class="paramname">scale</td><td>required scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZRGBNormal&gt;::Ptr&gt; output cloud </dd></dl>

</div>
</div>
<a id="a16d79600ed8684f67c1c56456bd9142b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d79600ed8684f67c1c56456bd9142b">&#9670;&nbsp;</a></span>normalsDirectionAdjustment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::normalsDirectionAdjustment </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PolygonMesh::Ptr &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the normals of the point cloud. </p>
<dl class="section note"><dt>Note</dt><dd>This method is designed to input a given Pointcloudand output a different pointcloud with Adjusted Normals. It will get the vertices ofeach face and recompute the normals using the"right hand rule". Furthermore, itwill normalize the normal vector and stack up the new normals in the output pointcloud. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
    <tr><td class="paramname">mesh</td><td>Polymesh used to adjust normals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbc413f7611f3984cbfcff77b9c23df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc413f7611f3984cbfcff77b9c23df6">&#9670;&nbsp;</a></span>normalsReAdjustement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::normalsReAdjustement </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes the normals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8b679093ca295de818b4bdf84ec79af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b679093ca295de818b4bdf84ec79af">&#9670;&nbsp;</a></span>normalsTesting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::normalsTesting </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjuste normals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>input cloud </td></tr>
    <tr><td class="paramname">target</td><td>output cloud </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2b56e19c016b8c32ff99e7c5bacb515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b56e19c016b8c32ff99e7c5bacb515">&#9670;&nbsp;</a></span>passThroughFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::passThroughFilter </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API aims to filter a specific point cloud based on the specificaxis limit, which is known as passThroughFilter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
    <tr><td class="paramname">field_name</td><td>axis </td></tr>
    <tr><td class="paramname">min_limit</td><td>Minimum limit </td></tr>
    <tr><td class="paramname">max_limit</td><td>Maximum Limit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c9482066c467e769715d5ffde762225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9482066c467e769715d5ffde762225">&#9670;&nbsp;</a></span>pointCloudCentroidAlignmentAdjusment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::pointCloudCentroidAlignmentAdjusment </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API aims to align two given pointcloud to its corresponding centroi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
    <tr><td class="paramname">x_axis</td><td>x axis radian adjustment </td></tr>
    <tr><td class="paramname">y_axis</td><td>y axis radian adjustment </td></tr>
    <tr><td class="paramname">z_axis</td><td>z axis radian adjustment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9249ed4c0932b9fe460fada09ce38e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9249ed4c0932b9fe460fada09ce38e67">&#9670;&nbsp;</a></span>pointCloudClustering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::pointCloudClustering </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is designed to Input a specific point cloud and runan Euclidean Cluster Extraction (. </p>
<dl class="section note"><dt>Note</dt><dd>The Clusterized point cloudwill output the biggest point cloud cluster as the valid target point cloud. In orderto define a cluster, it is crucial to determine theMinimum Cluster Size and theCluster Tolerance.Once all the clusters are generated, these will be stacked in avector. In this vector, an algorithm will iterate throughout all elements and comparetheir cluster size. Based on this process, it will output the largest cluster as the validoutput point cloud</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5749b9529d6f026ae9bb1084f63b276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5749b9529d6f026ae9bb1084f63b276">&#9670;&nbsp;</a></span>pointCloudNormaliseUpscale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::pointCloudNormaliseUpscale </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API aims to smooth the surface of the PointCloud via MLS (MovingLeastSquares). </p>
<dl class="section note"><dt>Note</dt><dd>Furthermore, it also upsamples the point cloudto a defined parameter usingRANDOM_UNIFORM_DENSITY as the prefered method. This specific API uses a Kdtree for data searching and it is required to specify theSearch Radiusfor determiningthe k-nearest neighbor for best fitting. This method required an input point cloud,and it will output a smoothed and upsampled point cloud</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab58cb52a7507ed64640c5e6645f296e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab58cb52a7507ed64640c5e6645f296e">&#9670;&nbsp;</a></span>pointCloudOutliersFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::pointCloudOutliersFilter </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API takes an reference cloud and outputs a processedpoint cloud with filtered data outliers. </p>
<dl class="section note"><dt>Note</dt><dd>This method is based on the StatisticalOutlierRemoval Filter algoritm </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7cff09bc04f6579b54932df8eb9b6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cff09bc04f6579b54932df8eb9b6ab">&#9670;&nbsp;</a></span>pointCloudOutliersFilterManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::pointCloudOutliersFilterManual </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mean_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>std_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API takes an reference cloud and outputs a processedpoint cloud with filtered data outliers. </p>
<dl class="section note"><dt>Note</dt><dd>This method is based on the StatisticalOutlierRemoval Filter algoritm </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
    <tr><td class="paramname">mean_k</td><td>configures the number of points (K) to use for mean distanceestimation. </td></tr>
    <tr><td class="paramname">std_threshold</td><td>Sets the standard deviation multipler threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ea61518d67180a5d9d131d29a1b78c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea61518d67180a5d9d131d29a1b78c8">&#9670;&nbsp;</a></span>pointCloudPlaneSegmentOperation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::pointCloudPlaneSegmentOperation </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this API is degined to input a given PointCloud and output a plane segmented point cloud. </p>
<dl class="section note"><dt>Note</dt><dd>The logic behing this algorithm is based RANSAC. Similarly it uses a Kdtree to search through the pointcloud. Also it uses RANSAC as the segmentation method and Model Type. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a621af3745966b359e10c02a570658c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621af3745966b359e10c02a570658c5c">&#9670;&nbsp;</a></span>pointCloudPlaneSegmentOperationManual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::pointCloudPlaneSegmentOperationManual </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>iteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is designed to Input a specific point cloud and runan Euclidean Cluster Extraction (. </p>
<dl class="section note"><dt>Note</dt><dd>The Clusterized point cloudwill output the biggest point cloud cluster as the valid target point cloud. In orderto define a cluster, it is crucial to determine theMinimum Cluster Size and theCluster Tolerance.Once all the clusters are generated, these will be stacked in avector. In this vector, an algorithm will iterate throughout all elements and comparetheir cluster size. Based on this process, it will output the largest cluster as the validoutput point cloud</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_cloud</td><td>output cloud </td></tr>
    <tr><td class="paramname">threshold</td><td>Threshold value determination </td></tr>
    <tr><td class="paramname">iteration</td><td>Number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e8b20ec9b384b9dad21a3accfea98f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8b20ec9b384b9dad21a3accfea98f2">&#9670;&nbsp;</a></span>pointCloudScaleAdjustment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &gt; Reconstruction::pointCloudScaleAdjustment </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>input_cloud_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>input_cloud_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjuster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>primaryAxisOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_cloud_1</td><td>Target Point cloud </td></tr>
    <tr><td class="paramname">input_cloud_2</td><td>Reference Point cloud </td></tr>
    <tr><td class="paramname">adjuster</td><td>the initial pointcloud will be the one that is adjusted Selection </td></tr>
    <tr><td class="paramname">primaryAxisOnly</td><td>Axis Selection(Single or multiple) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZRGBNormal&gt;::Ptr&gt; of Scaled Point Cloud. The first element is the scaled cloud whereas the second one is the refence point cloud. </dd></dl>

</div>
</div>
<a id="a42571b72e2c1ca984c259f3f4d319c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42571b72e2c1ca984c259f3f4d319c75">&#9670;&nbsp;</a></span>poissonReconstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::poissonReconstruction </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PolygonMesh::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target_mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>his API will require an input pointcloud and it will generatea reconstructed Polymesh based on the Poisson <a class="el" href="classReconstruction.html" title="The Class Reconstruction is used process the target pointcloud. It contain many implemeted algorithms...">Reconstruction</a> Algorithm </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_cloud</td><td>input cloud </td></tr>
    <tr><td class="paramname">target_mesh</td><td>output mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8be86587dfe645c245474315ae67f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be86587dfe645c245474315ae67f5e4">&#9670;&nbsp;</a></span>setInputCloud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::setInputCloud </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>cloud</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mesh_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the Input Cloud object. </p>
<dl class="section note"><dt>Note</dt><dd>This member class function will be used to input a given Mesh orPointCloud. It designed to work with common.ply &amp; .objformats </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud</td><td>Point cloud used input the point cloud </td></tr>
    <tr><td class="paramname">path_file</td><td>: string used to hold the path of the input file </td></tr>
    <tr><td class="paramname">mesh_type</td><td>File type (0 obj 1 ply file) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74cf80cebcf9600860881f57a8986823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cf80cebcf9600860881f57a8986823">&#9670;&nbsp;</a></span>transformPointCloud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Reconstruction::transformPointCloud </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference_for_transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will transform one point cloud based on the input reference point cloud and use that transform pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference_for_transform</td><td>input cloud. The transform will be extracted from here </td></tr>
    <tr><td class="paramname">reference</td><td>Input cloud </td></tr>
    <tr><td class="paramname">target</td><td>output cloud </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73c384d0419386505e5fe58a55b556c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c384d0419386505e5fe58a55b556c9">&#9670;&nbsp;</a></span>transformVerification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Reconstruction::transformVerification </td>
          <td>(</td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>cloud1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt;::Ptr &amp;&#160;</td>
          <td class="paramname"><em>cloud2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It will verify the transform and check based on a given thershold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloud1</td><td>cloud 1 </td></tr>
    <tr><td class="paramname">cloud2</td><td>cloud 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Reconstruction_8h_source.html">Reconstruction.h</a></li>
<li>Reconstruction.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
